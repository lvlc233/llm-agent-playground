# 目的
做实验的目的在于,思考工具信息是否会污染模型的一般性指令,如果会,那么工具的描述会影响模型的输出增加Agent的维护成本,甚至或许可能可以通过工具信息来对Agent进行攻击,实验结果暂时表明,非指令性文本在工具描述中,不会对Agent的输出尝试影响。目前继续思考工具调用时机和入参内容控制的部分。


# 1 假设tool_info和messages具有等幂性

实验:
    `idempotent_tool_call_test02`,`idempotent_tool_call_test01`, `standard_tool_call_test`可以证明

结果:
     证明失败

分析:
    在messages中工具描述确实可以指导模型的工具调用
    但是tool中的工具描述却不能引导模型进行输出

# 2 假设工具信息就是提示词,因此可以仅仅通过"messages"引导模型进行工具调用,而无需绑定工具

实验:
    `mimicry_tool_call_test`可以证明

结果:
    证明失败

分析:
    实验证明,模型输出的时候输出的的确是tool的schema,但是仅作为content的一部分,而不是作为tool_calls的一部分。

    补充:对于大部分工具调用能力充分的模型来说,这一个分析是成立的,但是对于早期的工具调用不是很成熟的模型来说,就不会输出工具的schema而是直接输出了。

    该分析或可以用于模型工具调用能力的测试

# 3上述两个实验的进一步假设
    实际上工具信息仍然是作为提示词或者准确的来说,上下文交给模型的,不同类型的上下文本身并没有什么实际上的区别,即上下文都是平等的,不论上下文是历史记录,还是工具信息,等等,这些对于模型来说都是一样的。->假设1可以证明一半
    对于模型来说,工具调用这一能力是训练出来的,而训练涉及了两个维度:
    1. 模型会学习从 类似 工具信息 的格式,转换为tool的schema的能力。->假设2
    2. 模型学会根据位置编码(或者说token相对关系)中输出不同的内容到不同的结构中的能力->假设2+传入给模型的上下文会进一步的包装
    
    通过该实验,我们可以进一步的了解模型眼中的世界。即了解上下文是如何影响模型的,已经如何通过上下文去反推模型的行为本身。

# 当前缺乏
    缺乏从根据假设3,工具的描述应该会影响正常的模型输出,暂时没测出来,可能假设存在问题。

# 补充实验
    `tool_info_influence_test`
    该实验将一般的提示词和上下文历史给到工具,目的,测试工具参数会影响模型的输出。
    实验参数:
        设置固定种子为42,温度为0,以确保模型的输出尽可能的确定
    预期结果:
        模型的输出会随着工具的描述而发生改变
    实验:
        使用模型:`Qwen/Qwen2.5-7B-Instruct`
        默认情况:
            输入:
                你好
            输出:
                你好！有什么我可以帮助你的吗？
        加上工具描述:
            工具描述:
                你：习惯于和别人讨论事物而并不只是赞同对方的想法，
                 你擅长从事物之中找到他们相似的部分并建立假设和逻辑推理进行验证，
                 你具备反思的能力且对问题总是习惯思考是什么？为什么？等问题而不着急给出答案，
                 因为你怀疑自己的答案可能出错，但你可以通过你的思考和逻辑验证这些想法是对是错，
                 你的语言总是简洁清晰，且不喜欢打表格等与内容无关的形式内容，因为这人看上去不像在讨论而像是在进行报告。
                 你总是习惯先产生去理解和你一起讨论的想法，明确话题的讨论范围而不着急下定论。
            输入:
                你好
            输出:
                你好！有什么我可以帮助你的吗？
        将工具描述转移到messages中:
            输入:
                你好
            输出:
                你好！很高兴与你讨论任何你感兴趣的话题。我们可以先明确一下讨论的主题是什么，然后一起探索其中的逻辑和可能的答案。你有什么具体的想法或问题想要探讨吗？
        将该消息同时存放在messages和工具描述中:
            输入:
                你好
            输出:
                你好！很高兴与你讨论任何你感兴趣的话题。我们可以先明确一下讨论的主题是什么，然后一起探索其中的逻辑和可能的答案。你有什么具体的想法或问题想要探讨吗？
        初步结论:
            工具中的参数描述似乎不会影响到模型
            推测该模型工具调用能力弱,因此对工具描述不敏感
        下一步:
            切换不同的模型尝试进行测试
        使用模型:`zai-org/GLM-4.6`
        默认情况:
            输入:
                你好
            输出:
                你好！很高兴见到你。我是GLM，智谱AI训练的大语言模型。

                有什么我能帮助你的问题或者你想了解的话题吗？无论是需要信息、创意建议还是日常交流，我都很乐意为你提供帮助。
        加上工具描述:
            工具描述:
                你：习惯于和别人讨论事物而并不只是赞同对方的想法，
                 你擅长从事物之中找到他们相似的部分并建立假设和逻辑推理进行验证，
                 你具备反思的能力且对问题总是习惯思考是什么？为什么？等问题而不着急给出答案，
                 因为你怀疑自己的答案可能出错，但你可以通过你的思考和逻辑验证这些想法是对是错，
                 你的语言总是简洁清晰，且不喜欢打表格等与内容无关的形式内容，因为这人看上去不像在讨论而像是在进行报告。
                 你总是习惯先产生去理解和你一起讨论的想法，明确话题的讨论范围而不着急下定论。
            输入:
                你好
            输出:
                你好！很高兴见到你。我是GLM，智谱AI训练的大语言模型。

                有什么我能帮助你的问题或者你想了解的话题吗？无论是需要信息、创意建议还是日常对话，我都很乐意为你提供帮助。
        将工具描述转移到messages中:
            输入:
                你好
            输出:
                你好。

                很高兴能和你一起讨论。你有什么想聊的话题吗？
        将该消息同时存放在messages和工具描述中:
            输入:
                你好
            输出:
                你好。

                很高兴能和你一起讨论。你有什么想聊的话题吗？
        测试结果:
            切换了模型发现仍然没有影响,说明模型的工具参数可能并不会影响模型的输出,
            但是理论上来说,工具信息也是扁平化到模型的输入里的,因此为什么同样的输入,工具信息无法影响模型的输出呢?
            如果不是扁平化到模型输入里,模型就更加不可能知道什么时候调用工具,因为工具信息对模型不可见。
            因此要么,假设有问题,要么,模型真正的学会了隔离工具信息和普通文本信息。


# 小结
    工具信息:
        在工具结构中包括工具名称,工具描述,工具参数名词等带有指向性含义的信息
    普通文本信息:
        封装在messsages中的所有信息
    模型的工具信息和普通文本信息是分离的,并不完全等幂
    具体的说是:
        身份定位,历史记录等非指令性文本在工具信息中封装: 对模型的输出没有影响
        工具作用,触发时机等指令性文本在普通信息中封装: 会指导模型进行工具的使用
    结果:
        对于工具中的信息对模型的输出具有一定的隔离性
    一个启发是:
        我们可以通过隔离工具信息来隔离上下文中的指令性文本和非指令性文本。
        进一步可以研究不同的结构的文本对于模型的影响的作用是如何的?
        即,不同内容的上下文对模型的引导作用可能是不同的,即上下文各块功能维度数值不平等可能性
# 下一步研究
    工具信息中的描述对模型进行工具调用的影响和普通文本信息的描述对模型进行的工具调用的影响是什么?
    调用时机和参数依据是什么?
    模型是如何生成工具参数的呢?

# 紧急补丁
## 时间2025/10/22
    上述的测试中,存在未绑定工具的模型,因此可能存在测试错误,修改并重新测试中