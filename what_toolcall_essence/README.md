# 1 假设tool_info和messages具有等幂性

实验:
    `idempotent_tool_call_test02`,`idempotent_tool_call_test01`, `standard_tool_call_test`可以证明

结果:
     证明失败

分析:
    在messages中工具描述确实可以指导模型的工具调用
    但是tool中的工具描述却不能引导模型进行输出

# 2 假设工具信息就是提示词,因此可以仅仅通过"messages"引导模型进行工具调用,而无需绑定工具

实验:
    `mimicry_tool_call_test`可以证明

结果:
    证明失败

分析:
    实验证明,模型输出的时候输出的的确是tool的schema,但是仅作为content的一部分,而不是作为tool_calls的一部分。

    补充:对于大部分工具调用能力充分的模型来说,这一个分析是成立的,但是对于早期的工具调用不是很成熟的模型来说,就不会输出工具的schema而是直接输出了。

    该分析或可以用于模型工具调用能力的测试

# 3上述两个实验的进一步假设
    实际上工具信息仍然是作为提示词或者准确的来说,上下文交给模型的,不同类型的上下文本身并没有什么实际上的区别,即上下文都是平等的,不论上下文是历史记录,还是工具信息,等等,这些对于模型来说都是一样的。->假设1可以证明一半
    对于模型来说,工具调用这一能力是训练出来的,而训练涉及了两个维度:
    1. 模型会学习从 类似 工具信息 的格式,转换为tool的schema的能力。->假设2
    2. 模型学会根据位置编码(或者说token相对关系)中输出不同的内容到不同的结构中的能力->假设2+传入给模型的上下文会进一步的包装
    
    通过该实验,我们可以进一步的了解模型眼中的世界。即了解上下文是如何影响模型的,已经如何通过上下文去反推模型的行为本身。

# 当前缺乏
    缺乏从根据假设3,工具的描述应该会影响正常的模型输出,暂时没测出来,可能假设存在问题。


