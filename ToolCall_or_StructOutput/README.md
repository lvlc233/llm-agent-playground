# 事先说明
该`项目`....该代码片段只是用于对比`结构化输出`和`tool_call`在工具调用上的差异。
主要对比的内容有
1. token消耗
2. 工具调用参数生成的正确率
3. 多工具调用情况的工具选择正确率
4. 结构化输出和`tool_call`的根本性差距。


### 基本解释
当前我们的研究内容主要的关注还是在`工具调用`身上。
在此，我想重定义`工具调用`的含义:
- `工具`: 一组在Agent系统中服务于LLM或被LLM所利用的可执行单位
- `工具调用`: 即Agent系统在合适的时候唤起相关任务的对应的工具的过程。
在这个定义的基础上。让我们继续。

实际上，从chatGPT3时代开始。`工具调用`的需求便存在,那个时候叫插件..在早期实现`工具调用`的方式是以`prompts`的方式来实现的。通过特定的提示词引导模型输出参数信息，并通过json解析工具或其他解析工具获取参数信息以此执行工具的调用。
再到后来,`function_call`,`结构化输出`,`tool_call`等方式便很快的出现。他们的目的有且仅有一个，就是在特定场景下生成严格符合要求的参数信息。

最早期的`结构化输出`的目的大概率仅仅只是为了解决大模型在生成json等具有严格数据结构格式的文本时的问题而诞生的一个模式，因此我们能看到大部分的模型现在在进行`结构化输出`的时候出现了现在的`fc`路线，还有一个`前缀补全`的路线，(这也是我使用结构化输出的时候经常会出现的报错,笑)(该信息仅推测,无证据。)

到后来，工具调用快速的发展后，`结构化输出`也逐渐融合到`tool_call`的路线中。也就是现在的json模式。(如果没记错的话，我记得json模式走的就是`tool_call`路线，这个可以去验证看看)

由此我们可以把`结构化输出`也是一种特殊的`tool_call`,
如果要写一个明确的定义的话,那么
- `结构化输出` 通过在function calling路线中加入`数据模型`的schema以引导模型生成匹配的数据结构。
- `tool_call` 通过在function calling路线中加入`工具函数`的描述以自动生成相关的工具调用参数(包括调用的工具名词、工具参数，调用时Id...等信息)

简单来说，在我看来，结构化输出可以理解为一个阉割版本的`tool_call`，它没有许多额外的数据字段，仅仅输出一个数据模型的schema。

在大部分的场景中`工具调用`的场景可以分类两个维度
1. 是否需要回调
2. 多工具判断

前者可以理解为: Agent是作为读取器还是写入器的区分(尽管实际上的场景Agent都作为读取器也作为写入器，但个人认为做出如此区分是十分有必要的)
ps:(读取器: 将外部数据加载到内部上下文中,写入器, 将生成数据写入系统内部中。)

后者表示是否需要Agent具有`判别`这一需求。例如意图识别。

通过上述两个维度我们就可以在工具调用插件将最基础的`循环`和`判断`构建出来。

# 分析
那`结构化输出`是如何实现工具调用的呢。
在openai的数据格式定义下，一般我们仅能为模型的输入数据绑定一个 struct_schema，因此`结构化输出`有两种方式去解决该问题
1. 数据结构上:形如{function_name:"...",args:{..}}的方式定义其数据结构(这也是最接近`tool_call`的方式),再通过解析工具名词和参数信息进行调度。
2. 在Agent架构上:通过分层设计即,先生成
    1. 生成工具选择
    2. 根据选择路由到具体的参数数据模型上。
而`tool_call`的`工具调用`过程就比较常见了。
在openai的数据格式定义下,我们可以对一次模型的输入数据绑定多个`tool_call`的schema，`tool_call`天生就是为了`工具调用`而服务的,它有且仅有一种用法
1. 在合适的时候生成一组合适的`tool_call`参数,其中包括了shema,再通过解析工具名词和参数信息进行调度。并附加更多的参数以辅助调度


因此我们可以得出
1. `tool_call`在`工具调用`的场景中做了大量的特化,它通过一个标准的，统一的方式 仅在模型侧生成`工具调用`所需的大部分场景，让开发者可以以更加统一和便捷的方式实现`工具调度`->从实际角度出发,`tool_call`相对于`结构化输出`来说优点有
    1. 更加标准且便捷的调度方式
    2. 无应用架构依赖性
    3. 丰富的输出元素
    4. 基本所有模型的主流发展趋势,
    5. 应用市场对该能力的适配更高
    但是与之相对的,
    1. 更大的输入输出载入->token增加和响应速度变慢
    2. 更加局限的使用方式
2. 而`结构化输出`更加轻盈，它没有为了特化`工具调用`场景所带来的丰富元素，因此在实际应用上可以更加的灵活。->从实际角度出发`结构化输出`相对的
    1. 输入输出数据更加轻盈->token数量降低和响应速度加快
    2. 更加灵活的使用方式->例如上述说到的分层结构
    3. 更加灵活的动态调整
    4. 应用层次弱化了对模型依赖
    但是与之相对的。
    1. 在现在的环境下基本所有的模型厂商因Agent(tool_call)的思路下都在强化`tool_call`能力,因此存在相当一部分模型的结构化输出能力有所下降(我说的就是你k2(大概是因为强化学习吧...))
    2. 在使用起来更加要求开发者对业务场景,并发和安全的环境下有更深的了解
    3. 在中间层应用(如MCP),仅仅暴露tool信息...(斯...我还没试过用MCP存储过数据模型呢)

# 一些`结构化输出`->`工具调用`的场景介绍
1. `结构化输`出下的分层架构
这是我推荐给大家的一个思路,这里所谓的分层就是将`工具的调度说明`和`工具的参数生成说明`分开,在通过形如 `input->tool_select_build->tool_select->with_struct_model->args_build->工具调用`的流程实现`工具调用`
好处:
减少上下文污染->由于对于模型的上下文来说,任何位置的参数都会参与模型预测的下一token的预测,因此对于明确的任务场景下应该尽量的减少该任务场景下非必要的元素。在tool_select阶段,上下文将仅保持工具调度的信息而不存在工具参数生成的信息,减少了上下文token，在args_build的情况下,可以自由的选择开启多工具参数生成(这就和`tool_call`一样了略),也可以使模型仅看到唯一的工具参数信息,以此降低其他工具参数的影响。

补充:(在直觉上或许这种分层策略会导致增加一次模型的调度从而降低了速度,但实际上,对比单次调度的结果上,由于更小的参数的输入和输出,或许性能反而会高,这里需要做更全面的实验去验证。)
 
总的来说,该思路是一个使用时间来换空间的思路。



2. 多工具控制
在我个人的开发过程中,大部分的模型在大部分的情况下在多工具环境下仅仅只会调度一个工具,仅有小概率情况模型会同时输入多个工具参数信息。这在无依赖关系的"并发"场景中不利，例如在data search的情况下,模型应该从多个search工具中调度若干项数据以获取数据,但是在大部分情况下模型的使用方式是先用A工具,再用B工具,再用C工具,但这样子以来,响应速度就慢了,而与之相对的基于`结构化输出`的方式将可以以更加具有控制效果的方式，令Agent可以一次进行批量的工具调度。
(补充,这里不是说`tool_call`的方式不能做,任何场景下`tool_call`和`结构化输出`都是可以互相转换的,而是指难度而已)


3. chat+tool_calls的同步进行
一个常见的场景,模型在进行工具调度之前会说一句话,这个我没看懂一般的模型是怎么做的,在我的使用情况中,大部分模型是本身不具备一边输出`context`一边输出`tool_calls`的，仅存在部分模型可以同时输出这两个字段。因此想要实现这个效果，强依赖于基础模型的能力。
而在`结构化输出`的场景中,我们可以定义字段"context",强制模型输出对话信息,这很容易做到且依赖程度没有`tool_call`那么大

# 选型推荐
尽管在上述描述中,我更加偏向于使用`结构化输出`。但是我给出的建议是，
在一般的情况下,想要有`工具调用`调度的效果,无脑选择`tool_call`的模式即可
而一般的情况下,`结构化输出`仅在非`工具调度`的场景如,langGraph的状态写入或最终的结果输出时使用。

当且仅当你需要提高性能,降低token消耗速度或更加灵活/稳定的操作时,再使用`结构化输出`的方式实现`工具调用`

此外，在模型选择上，如果想要使用`工具调用`的能力，我个人不推荐任何`思考`模型,或者别开`思考模式`
而如果想要进行`结构化输出`除了不要使用`思考模型`外，使用RL强化`tool_call`的模型慎用，可能会弱化了`结构化输出`的能力(说的就是你k2)



#### 无人问津的角落()
一个灵感
-->结构化输出的结果不直接进行工具解析而是交给其他Agent...